/** @file

MODULE						: InterPLastRunLevH263Impl

TAG								: IPLRLH263I

FILE NAME					: InterPLastRunLevH263Impl.cpp

DESCRIPTION				: A class to implement a last-run-level codec on the 
										2-D quantised dct coeffs of an Inter-P coded 8x8 block 
										as defined in the H.263 standard. It implements the 
										IRunLengthCodec interface.

REVISION HISTORY	:
									: 

COPYRIGHT					: 

RESTRICTIONS			: 
===========================================================================
*/
#ifdef _WINDOWS
#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers
#include <windows.h>
#else
#include <stdio.h>
#endif

#include "InterPLastRunLevH263Impl.h"
#include "LastRunLevelH263List.h"

typedef short pCoeffType;

/*
---------------------------------------------------------------------------
	Constants.
---------------------------------------------------------------------------
*/
const int InterPLastRunLevH263Impl::zigZagPos[64] =
{
	 0,	 1,	 8, 16,	 9,	 2,	 3,	10,
	17,	24,	32,	25,	18,	11,	 4,	 5,
	12,	19,	26,	33,	40,	48,	41,	34,
	27,	20,	13,	 6,	 7,	14,	21,	28,
	35,	42,	49,	56,	57,	50,	43,	36,
	29,	22,	15,	23,	30,	37,	44,	51,
	58,	59,	52,	45,	38,	31,	39,	46,
	53,	60,	61,	54,	47,	55,	62,	63
};

/*
---------------------------------------------------------------------------
	Construction and Destruction.
---------------------------------------------------------------------------
*/
InterPLastRunLevH263Impl::InterPLastRunLevH263Impl(void)
{
}//end constructor.

InterPLastRunLevH263Impl::~InterPLastRunLevH263Impl(void)
{
}//end destructor.

/*
---------------------------------------------------------------------------
	Interface Methods.
---------------------------------------------------------------------------
*/
/** Encode the input to a run-length structure.
Encode the input 2-D 8x8 block of Dct coeffs into the
output last-run-level struct list.
@param in		:	Input 8x8 block.
@param rle	:	Last-run-level struct generated by the encode.
@return			: none.
*/
void InterPLastRunLevH263Impl::Encode(void* in, void* rle)
{
	// Interpret the param list for this implementation.
	pCoeffType*						coeff		= (pCoeffType *)in;
	LastRunLevelH263List* lrlList = (LastRunLevelH263List *)rle;
	LastRunLevelH263*			lrl			= lrlList->GetList();
	// None encoded yet.
	lrlList->SetNumOfElements(0);
	int elements = 0;

	// Scanned in zigzag order.
	unsigned char run = 0; // Reset.
	for(int c = 0; c < 64; c++)
	{
		pCoeffType x = coeff[zigZagPos[c]];
		if( x == 0)	// Most likely.
			run++;
		else				// Valid last-run-level.
		{
			lrl[elements].last	= 0;	// Assume not last until proven guilty.
			lrl[elements].run		= run;
			lrl[elements].level	= x;
			// Reset.
			run = 0;
			elements++;
		}//end else...
	}//end for c...
	// Set the last element and check that there were any non-zero elements.
	if(elements > 0)
		lrl[elements-1].last = 1;
	else	// Indicate no elements.
	{
		lrl[0].last		= 1;
		lrl[0].run		= run;
		lrl[0].level	= 0;
	}//end else...

	// Encoded length.
	lrlList->SetNumOfElements(elements);
}//end Encode.

/** Decode a run-length struct to the output.
Decode the input last-run-level struct list into the
output 2-D 8x8 block of Dct coeffs. Assumes there is
at least one element in the input list.
@param rle	:	Last-run-level struct to decode.
@param out	:	Output 8x8 block generated by the decode.
@return			: none.
*/
void InterPLastRunLevH263Impl::Decode(void* rle, void* out)
{
	// Interpret the param list for this implementation.
	LastRunLevelH263List* lrlList = (LastRunLevelH263List *)rle;
	LastRunLevelH263*			lrl			= lrlList->GetList();
	pCoeffType*						coeff		= (pCoeffType *)out;

	// Scanned in zigzag order. Start with first element 
	// and assume that it exists.
	int						element = 0;
	unsigned char run			= lrl[0].run;
	unsigned char last		= lrl[0].last;
	pCoeffType		level		= lrl[0].level;
	for(int c = 0; c < 64; c++)
	{
		if(run > 0) // Most likely.
		{
			coeff[zigZagPos[c]] = 0;
			run--;
		}//end if run...
		else				// Read element last-run-level and load next.
		{
			coeff[zigZagPos[c]] = level;
			if(!last)
			{
				// Next.
				element++;
				last	= lrl[element].last;
				run		= lrl[element].run;
				level	= lrl[element].level;
			}//end if !last...
			else
			{
				run = 255;	// Infinity.
			}//end else...
		}//end else...
	}//end for c...

}//end Decode.
